/**
 this module is here to offer true typing for the output of query `p moon query projects %QUERY% --json` file. Discord question: https://discord.com/channels/974160221452763146/974160221452763149/1105784724951150642
 */
import { z } from "zod";
import { projectSchema as moonProjectSchema } from "./moon/by-state-files/project";
import { projectLanguageSchema } from "./moon/by-state-files/project-config";
// import { inheritedTasksConfigSchema } from "./moon/by-state-files/moon-project-config";

// const nodeInheritedConfigSchema = inheritedTasksConfigSchema.extend({
//   implicitDeps: z.array(z.string()).optional(),
//   implicitInputs: z.array(z.string()).optional(),
//   extends: z.string().nullable().optional(),
// })
// const nodeConfigSchema = z.union([projectSchema, z.object({})])

// const nodeSchema = projectSchema.extend({
//   config: nodeConfigSchema,
//   inheritedConfig: nodeInheritedConfigSchema,
// })

/**
 validates a subset of the .moon/projectGraph.json which will form the basis
 of our own projectGraph type

 The edges etc seem to be generated by the lib petgraph - https://depth-first.com/articles/2020/02/03/graphs-in-rust-an-introduction-to-petgraph/
 */
export const moonQueryProjects = z.object({
  projects: z.array(moonProjectSchema),
  options: z.object({
    alias: z.string().nullable(),
    affected: z.boolean().nullable(),
    id: z.string().nullable(),
    json: z.boolean().nullable(),
    language: projectLanguageSchema.nullable(),
    query: z.string().nullable(),
    source: z.string().nullable(),
    tags: z.string().nullable(),
    tasks: z.string().nullable(),
    type_of: z.string().nullable()
  })
});

export type MoonQueryProjects = z.infer<typeof moonQueryProjects>;

// type MoonProjectGraph = z.infer<typeof moonProjectGraph>;
// expectTypeOf<MoonProjectGraphSubset>().toMatchTypeOf<>

// type BaseProject = z.infer<typeof baseProjectSchema>

// export const projectSourceConfigSchema = baseProjectSourceSchema.merge(z.object({
//   /** to be properly validated */
//   location: z.string(),
//   active: z.optional(z.boolean()),

//   detectProject: z.union([
//     z.array(
//       z.function()
//       .args(z.object({
//         tree: z.custom<Tree>(), // no implementation function here - not user supplied
//         sourceLocation: sourceLocation,
//       }))
//       .returns(z.optional(
//         projectConfigSchema,
//         // .implement((x) => )
//       )),
//     ),
//     projectConfigSchema,
//   ])
// })
// )

// export type BaseProject = {
//   language: Language
//   type: ProjectType
//   name: string
//   aliases: Aliases
// }
